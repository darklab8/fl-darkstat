package disco

import (
	"crypto/md5"
	"encoding/json"
	"fmt"
	"io"
	"strings"

	"github.com/darklab8/fl-darkstat/darkstat/configs_export"
	"github.com/darklab8/fl-darkstat/darkstat/front/types"
	"github.com/darklab8/fl-darkstat/darkstat/settings/logus"
)

type TdCacheKey string

type DiscoCompat struct {
	Nickname string
	Data     *configs_export.DiscoveryTechCompat
}

type Item interface {
	GetNickname() string
	GetTechCompat() *configs_export.DiscoveryTechCompat
}

func GetTdDiscoCacheKey(shared *types.SharedData, nickname string) TdCacheKey {
	if !shared.ShowDisco {
		return ""
	}
	cache_key_data := marshalIDs(shared, nickname)
	h := md5.New()
	_, err := io.WriteString(h, cache_key_data)
	logus.Log.CheckWarn(err, "failing to get disco key, md5 hash value problems")
	return TdCacheKey(fmt.Sprintf("%x", h.Sum(nil)))
}

func GetDiscoCacheMap(items []Item, shared *types.SharedData) map[TdCacheKey]DiscoCompat {
	var cache map[TdCacheKey]DiscoCompat = map[TdCacheKey]DiscoCompat{}

	if !shared.ShowDisco {
		return cache
	}
	for _, item := range items {
		nickname := item.GetNickname()
		cache_key := GetTdDiscoCacheKey(shared, nickname)
		cache[cache_key] = DiscoCompat{
			Nickname: nickname,
			Data:     item.GetTechCompat(),
		}
	}
	return cache
}

func marshalIDs(shared *types.SharedData, item_nickname string) string {

	var compat_by_id map[string]float64 = make(map[string]float64)

	compat_by_id[""] = shared.Config.GetCompatibilty(item_nickname, "")

	for _, id := range shared.Ids {
		compat := shared.Config.GetCompatibilty(item_nickname, id.Nickname)

		// data size saving
		if compat <= 0.1 {
			continue
		}

		compat_by_id[string(id.ShortNickname)] = compat
	}

	bytes, _ := json.Marshal(compat_by_id)
	return strings.ReplaceAll(string(bytes), "\"", "'")
}
