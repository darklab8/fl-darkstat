package front

import (
	"fmt"
	"github.com/darklab8/fl-darkstat/darkstat/configs_export"
	"github.com/darklab8/fl-darkstat/darkstat/front/tab"
	"github.com/darklab8/fl-darkstat/darkstat/configs_export/trades"
	"github.com/darklab8/fl-darkstat/darkstat/front/types"
	"github.com/darklab8/fl-darkstat/darkstat/front/urls"
	"github.com/darklab8/fl-darkstat/configs/cfg"
	"github.com/darklab8/fl-darkstat/darkstat/front/frmt"
	"math"
	"strconv"
	"strings"
)

func BaseDetailedUrl(base *configs_export.Base, tab_mode BaseMode) string {

	if tab_mode == BaseShowShops {
		return "bases/marketgoods/mg_" + strings.ToLower(base.Nickname.ToStr())
	} else if tab_mode == BaseShowMissions {
		return "bases/missions/msns_" + strings.ToLower(base.Nickname.ToStr())
	} else if tab_mode == BaseTabTrades {
		return "bases/trades/trades_" + strings.ToLower(base.Nickname.ToStr())
	} else if tab_mode == BaseTabOres {
		return "bases/ores/ore_" + strings.ToLower(base.Nickname.ToStr())
	} else if tab_mode == BaseAllRoutes {
		return "bases/routes/route_" + strings.ToLower(base.Nickname.ToStr())
	}

	panic("not supported mode for base")
}

type BaseMode int64

const (
	BaseShowShops BaseMode = iota
	BaseShowMissions
	BaseTabTrades
	BaseTabOres
	BaseAllRoutes
)

templ BasesTable(bases []*configs_export.Base, tab_mode BaseMode, pinm tab.PinMod, shared *types.SharedData, data *configs_export.Exporter) {
	<table class="sortable">
		<thead>
			<tr>
				if tab_mode != BaseTabOres {
					<th style="width:200px;">Base</th>
				} else {
					<th style="width:200px;">Mining Zone</th>
				}
				if pinm == tab.PinMode {
					<th style="width:50px;">Select</th>
					<th style="width:50px;">Select</th>
				}
				if tab_mode != BaseTabOres {
					<th style="width:50px;">Owner - Faction</th>
				}
				if tab_mode == BaseTabOres {
					<th style="width:50px;">
						@frmt.MultiLinestring([]string{"Dynamic Loot", "Min-Max", "(Difficulty)"})
					</th>
				}
				<th style="width:50px;">System</th>
				if shared.ShowDisco {
					<th style="width:5px;">
						@frmt.MultiLinestring([]string{"Not for", "tran", "sports"})
					</th>
				}
				<th style="width:25px;">
					@frmt.MultiLinestring([]string{"Nav", "Map"})
				</th>
				if tab_mode == BaseShowMissions {
					<th style="width:50px;">
						@frmt.MultiLinestring([]string{"Min", "Award"})
					</th>
					<th style="width:50px;">
						@frmt.MultiLinestring([]string{"Max", "Award"})
					</th>
					<th style="width:50px;">
						@frmt.MultiLinestring([]string{"Min", "Offers"})
					</th>
					<th style="width:50px;">
						@frmt.MultiLinestring([]string{"Max", "Offers"})
					</th>
					<th style="width:50px;">
						@frmt.MultiLinestring([]string{"Vingettes", "Offers Limit"})
					</th>
				}
				if tab_mode == BaseTabTrades || tab_mode == BaseTabOres {
					<th style="width:50px;">@frmt.MultiLinestring([]string{"Best","Transport","profit/v", "¢/sec"})</th>
					if shared.ShowDisco {
						<th style="width:50px;">@frmt.MultiLinestring([]string{"Best","Frigate","profit/v", "¢/sec"})</th>
						<th style="width:50px;">@frmt.MultiLinestring([]string{"Best","Freighter","profit/v", "¢/sec"})</th>
					}
				}
				<th style="width:100px;">Region</th>
				if tab_mode == BaseShowMissions {
					<th style="width:50px;">Ship Ranks</th>
					<th style="width:50px;">Enemies</th>
					<th style="width:50px;">Error</th>
				}
				if tab_mode != BaseTabOres {
					<th style="width:50px;">Base Nickname</th>
				} else {
					<th style="width:50px;">Zone Nickname</th>
				}
				<th style="width:50px;">
					@frmt.MultiLinestring([]string{"System", "Nick."})
				</th>
				<th style="width:20px;">Pos X</th>
				<th style="width:20px;">Pos Y</th>
				<th style="width:20px;">Pos Z</th>
				<th style="width:25px;">
					@frmt.MultiLinestring([]string{"Base", "Name ID"})
				</th>
				<th style="width:5px;">
					@frmt.MultiLinestring([]string{"Infocard", "ID"})
				</th>
				<th style="width:5px;">
					@frmt.MultiLinestring([]string{"Rech", "able"})
				</th>
				<th style="max-width:100%;"></th>
			</tr>
		</thead>
		<tbody>
			for _, base := range bases {
				if tab_mode == BaseTabTrades || tab_mode == BaseTabOres {
					@BaseRow(base, tab_mode, pinm, shared, data.GetBaseTradePaths(base))
				} else {
					@BaseRow(base, tab_mode, pinm, shared, nil)
				}
				
			}
		</tbody>
	</table>
}

templ BaseRow(base *configs_export.Base, tab_mode BaseMode, pinm tab.PinMod, shared *types.SharedData, routes *configs_export.BaseAllTradeRoutes) {
	@tab.TrFromMain(tab.NewTr(base.Nickname.ToStr(), BaseDetailedUrl(base, tab_mode), pinm, tab.WithTransportUnreachable(base.IsTransportUnreachable))) {
		@tab.PinTd(base.Nickname.ToStr(), base.Name, pinm)
		@tab.PinSelectLeftRight(pinm, BaseDetailedUrl(base, tab_mode))
		if tab_mode != BaseTabOres {
			<td>
				@frmt.WriteFactioName(base.FactionName)
			</td>
		}
		if tab_mode == BaseTabOres {
			<td>{ strconv.Itoa(base.DynamicLootMin) } - { strconv.Itoa(base.DynamicLootMax) } ( { strconv.Itoa(base.DynamicLootDifficulty) } ) </td>
		}
		<td>
			@frmt.WriteSystemName(base.System)
		</td>
		if shared.ShowDisco {
			<td>
			{ strconv.FormatBool(base.IsTransportUnreachable) }
			</td>
		}
		<td>{ base.SectorCoord }</td>
		if tab_mode == BaseShowMissions {
			if base.Missions != nil {
				<td>{ strconv.Itoa(base.Missions.MinMoneyAward) }</td>
				<td>{ strconv.Itoa(base.Missions.MaxMoneyAward) }</td>
				<td>{ strconv.Itoa(base.Missions.MinOffers) }</td>
				<td>{ strconv.Itoa(base.Missions.MaxOffers) }</td>
				<td>{ strconv.Itoa(base.Missions.Vignettes) }</td>
			} else {
				<td></td><td></td><td></td><td></td><td></td>		
			}
		}
		if routes != nil {
			<td
				class="route_transport" 
			> // routesinfo={ RoutesInfoJSON(base.BaseAllTradeRoutes, shared, trades.RouteTransport) }
				if routes.BestTransportRoute != nil {
					{ fmt.Sprintf("%2.2f", routes.BestTransportRoute.GetProffitPerTime() * 100) }
				} else {
					0
				}
			</td>
			if shared.ShowDisco {
				<td class="route_frigate"> // routesinfo={ RoutesInfoJSON(base.BaseAllTradeRoutes, shared, trades.RouteFrigate) }
					if routes.BestFrigateRoute != nil {
						{ fmt.Sprintf("%2.2f", routes.BestFrigateRoute.GetProffitPerTime() * 100) }
					} else {
						0
					}
				</td>
				<td class="route_freighter"> // routesinfo={ RoutesInfoJSON(base.BaseAllTradeRoutes, shared, trades.RouteFreighter) }
					if routes.BestFreighterRoute != nil {
						{ fmt.Sprintf("%2.2f", routes.BestFreighterRoute.GetProffitPerTime() * 100) }
					} else {
						0
					}
				</td>
			}
		}
		<td>
			@frmt.WriteRegionName(base.Region)
		</td>
		if tab_mode == BaseShowMissions {
			if base.Missions != nil {
				<td>{ strings.Join(strings.Fields(fmt.Sprint(base.Missions.NpcRanksAtBase)), ",") }</td>
				<td class="seo">
					@PrintEnemies(EnemistToList(base.Missions.EnemiesAtBaseMap))
				</td>
				<td class="seo">
					if base.Missions.Err != nil {
						{ base.Missions.Err.Error() }
					}
				</td>
			} else {
				<td></td><td></td><td></td>
			}
		}
		<td class="seo">{ base.Nickname.ToStr() }</td>
		<td class="seo">{ base.SystemNickname }</td>
		<td>{ fmt.Sprintf("%.0f", base.Pos.X) }</td>
		<td>{ fmt.Sprintf("%.0f", base.Pos.Y) }</td>
		<td>{ fmt.Sprintf("%.0f", base.Pos.Z) }</td>
		<td class="seo">{ strconv.Itoa(base.StridName) }</td>
		<td class="seo">{ strconv.Itoa(base.InfocardID) }</td>
		<td>{ frmt.FormatBoolAsYesNo(base.Reachable) }</td>
		@tab.TdInfoCardClick(configs_export.InfocardKey(base.Nickname), base.Nickname.ToStr(), pinm, shared, tab.InfocardClickOpts{})
	}
}

// https://www.cssscript.com/minimalist-table-sortable/#:~:text=Description%3A-,sorttable.,clicking%20on%20the%20table%20headers
// https://www.cssscript.com/fast-html-table-sorting/
templ BasesT(bases []*configs_export.Base, tab_mode BaseMode, mode tab.ShowEmpty, shared *types.SharedData, data *configs_export.Exporter) {
	if tab_mode == BaseShowShops {
		@TabMenu(urls.Bases, mode, shared)
	} else if tab_mode == BaseShowMissions {
		@TabMenu(urls.Missions, mode, shared)
	} else if tab_mode == BaseTabTrades {
		@TabMenu(urls.Trades, mode, shared)
	} else if tab_mode == BaseTabOres {
		@TabMenu(urls.Asteroids, mode, shared)
	} else if tab_mode == BaseAllRoutes {
		@TabMenu(urls.TravelRoutes, mode, shared)
	}
	@tab.TabContent() {
		<div class="splitter">
			@tab.LeftTable(){
				@tab.TableTop(){
					@tab.FilterBar(&types.SharedData{}) {
						// Turning off this feature because it has 170+mb bug size increasig for trades.html
						// if tab_mode == BaseTabTrades || tab_mode == BaseTabOres {
						// 	<input
						// 		type="text"
						// 		id="input_route_min_dist"
						// 		class="filter_input" 
						// 		placeholder="Trading route minimal distance (in seconds)"
						// 		onkeyup="FilteringForDistances()"
						// 	/>
						// }
					}
					<div id="table-top-main">
						@BasesTable(bases, tab_mode, tab.MainMode, shared, data)
					</div>
					<div id={ "table-top-main" + string(tab.PinMode) } class="hidden">
						@BasesTable(bases, tab_mode, tab.PinMode, shared, data)
					</div>
				}
				@tab.TableBottom(){
					<div id="table-bottom-main">
						if tab_mode == BaseShowShops {
							@BaseMarketGoodsBase()
						} else if tab_mode == BaseShowMissions {
							@BaseMissionsBase()
						} else if tab_mode == BaseTabTrades {
							@BaseTradesShared(shared)
						} else if tab_mode == BaseTabOres {
							@BaseTradesShared(shared)
						} else if tab_mode == BaseAllRoutes {
							@BasesRoutesShared(shared)
						}
					</div>
					<div id={ "table-bottom-main" + string(tab.PinMode) } class="hidden">
					
						if tab_mode == BaseShowShops {
							@BaseMarketGoodsBase()
						} else if tab_mode == BaseShowMissions {
							@BaseMissionsBase()
						} else if tab_mode == BaseTabTrades {
							@BaseTradesShared(shared)
						} else if tab_mode == BaseTabOres {
							@BaseTradesShared(shared)
						}  else if tab_mode == BaseAllRoutes {
							@BasesRoutesShared(shared)
						}
					</div>
				}
			}
			@tab.InfocardTable(){
				@tab.InfocardShared()
			}
		</div>
	}
}

templ BaseMarketGoodsBase() {
	<table class="sortable">
		<thead>
			<tr class="flexed-tr">
				<th style="width:200px;">Good</th>
				<th style="width:10px;">Type</th>
				<th style="width:10px;">
					@frmt.MultiLinestring([]string{"Price", "to sell", "to base"})
				</th>
				<th style="width:10px;">
					@frmt.MultiLinestring([]string{"Price", "to buy", "from base"})
				</th>
				<th style="width:10px;">
					@frmt.MultiLinestring([]string{"Volume"})
				</th>
				<th style="width:10px;">
					@frmt.MultiLinestring([]string{"comm.","ship", "class"})
				</th>
				<th style="width:10px;">
					@frmt.MultiLinestring([]string{"Lev.", "Req."})
				</th>
				
				<th style="width:10px;">
					@frmt.MultiLinestring([]string{"Rep.", "Req."})
				</th>
				<th style="width:10px;">
					@frmt.MultiLinestring([]string{"Base", "Sells"})
				</th>
				// <th style="width:10px;">
				// 	@frmt.MultiLinestring([]string{"Price", "Modifier"})
				// </th>
				<th style="width:10px;">
					@frmt.MultiLinestring([]string{"Price", "Base"})
				</th>
				<th style="width:10px;">Nickname</th>
				<th style="width:10px;">HpType</th>
				<th style="width:10px;">
					@frmt.MultiLinestring([]string{"Server", "Override"})
				</th>
				<th style="max-width:100%;"></th>
			</tr>
		</thead>
		<tbody>
			{ children... }
		</tbody>
	</table>
}

templ BaseMarketGoods(name string, goods map[configs_export.CommodityKey]*configs_export.MarketGood, tab_mode BaseMode) {
	@tab.BottomFilterBar()
	<div class="bottom_name">{ name }</div>
	@BaseMarketGoodsBase() {
		for _, good := range frmt.SortedMarketGoods(goods) {
			<tr
				hx-get={ types.GetCtx(ctx).SiteRoot + tab.InfocardURL(configs_export.InfocardKey(good.Nickname)) }
				hx-trigger="click"
				hx-target="#infocard_view"
				hx-swap="innerHTML"
				preload="mouseover"
				onclick="RowHighlighter(this)"
			>
				<td>
					@frmt.WriteLimit(200) {
						{ good.Name + frmt.FormattedShipClassOfCommodity(good.ShipClass) }
					}
				</td>
				<td>
					@frmt.WriteGoodType(string(good.Category))
				</td>
				<td>
					if good.PriceBaseBuysFor != nil {
						{ strconv.Itoa(*good.PriceBaseBuysFor) }
					}
				</td>
				<td>{ strconv.Itoa(good.PriceBaseSellsFor) }</td>
				<td>{ fmt.Sprintf("%.0f", good.Volume) }</td>
				<td>{ frmt.FormattedShipClassOfCommodity2(good.ShipClass) }</td>
				<td>{ strconv.Itoa(good.LevelRequired) }</td>
				<td>{ fmt.Sprintf("%.2f", good.RepRequired) }</td>
				<td>{ frmt.FormatBaseSells(good.BaseSells) }</td>
				// <td>{ fmt.Sprintf("%.2f", good.PriceModifier) }</td>
				<td>{ strconv.Itoa(good.PriceBase) }</td>
				<td>
					@frmt.WriteLimit(200) {
						{ good.Nickname }
					}
				</td>
				<td>{ good.HpType }</td>
				<td>{ strconv.FormatBool(good.IsServerSideOverride) }</td>
				<td></td>
			</tr>
		}
	}
}

templ BaseMissionsBase() {
	<table class="sortable">
		<thead>
			<tr class="flexed-tr">
				<th style="width:165px;">Faction</th>
				<th style="width:25px;">
					@frmt.MultiLinestring([]string{"Min", "Difficulty"})
				</th>
				<th style="width:50px;">
					@frmt.MultiLinestring([]string{"Max", "Difficulty"})
				</th>
				<th style="width:25px;">Chance</th>
				<th style="width:25px;">
					@frmt.MultiLinestring([]string{"Min", "Money", "Award"})
				</th>
				<th style="width:25px;">
					@frmt.MultiLinestring([]string{"Max", "Money", "Award"})
				</th>
				<th style="width:25px;">NpcRanks</th>
				<th style="width:25px;">Enemies: Faction Name ( Faction Nickname, NPcs exist for NpcRanks)</th>
				// <th style="width:50px;">Rep Req</th> // can it be used?
				<th style="width:25px;">Error</th>
				<th style="width:25px;">Faction Nickname</th>
				<th style="max-width:100%;"></th>
			</tr>
		</thead>
		<tbody>
			{ children... }
		</tbody>
	</table>
}

templ BaseMissions(name string, mission_givers configs_export.BaseMissions, tab_mode BaseMode) {
	@tab.BottomFilterBar()
	<div class="bottom_name">{ name }</div>
	@BaseMissionsBase() {
		for _, msn_giver := range mission_givers.Factions {
			<tr
				hx-get={ types.GetCtx(ctx).SiteRoot + tab.InfocardURL(msn_giver.Infocard) }
				hx-trigger="click"
				hx-target="#infocard_view"
				hx-swap="innerHTML"
				preload="mouseover"
				onclick="RowHighlighter(this)"
			>
				<td>
					@frmt.WriteFactioName(msn_giver.FactionName)
				</td>
				<td>{ fmt.Sprintf("%2.2f", msn_giver.MinDifficulty) }</td>
				<td>{ fmt.Sprintf("%2.2f", msn_giver.MaxDifficulty) }</td>
				<td>{ strconv.Itoa(msn_giver.Weight) }</td>
				<td>{ strconv.Itoa(msn_giver.MinAward) }</td>
				<td>{ strconv.Itoa(msn_giver.MaxAward) }</td>
				<td>{ strings.Join(strings.Fields(fmt.Sprint(msn_giver.NpcRanks)), ",") }</td>
				<td>
					@PrintEnemies(msn_giver.Enemies)
				</td>
				<td>
					if msn_giver.Err != nil {
						{ msn_giver.Err.Error() }
					}
				</td>
				<td>{ msn_giver.FactionNickname }</td>
				<td></td>
			</tr>
		}
	}
}

func EnemistToList(enemies map[string]configs_export.EnemyFaction) []configs_export.EnemyFaction {
	var result []configs_export.EnemyFaction = make([]configs_export.EnemyFaction, 0, len(enemies))
	for _, enemy := range enemies {
		if enemy.Nickname == "" {
			continue
		}
		result = append(result, enemy)
	}
	return result
}

templ PrintEnemies(enemies []configs_export.EnemyFaction) {
	for enemy_index, enemy := range enemies {
		{ enemy.Name } ( { enemy.Nickname }, { strconv.FormatBool(enemy.NpcExist) } )
		if enemy_index != len(enemies) - 1 {
			{ ", " }
		}
	}
}

templ BaseTradesShared(shared *types.SharedData) {
	<table class="sortable">
		<thead>
			<tr class="flexed-tr">
				<th style="width:200px;">Commodity</th>
				<th style="width:50px;">
					@frmt.MultiLinestring([]string{"Transport", "Profit/v/t", "¢ents/sec"})
				</th>
				if shared.ShowDisco {
					<th style="width:50px;">
						@frmt.MultiLinestring([]string{"Frigate", "Profit/v/t", "¢ents/sec"})
					</th>
					<th style="width:50px;">
						@frmt.MultiLinestring([]string{"Freighter", "Profit/v/t", "¢ents/sec"})
					</th>
				}
				<th style="width:50px;">
					@frmt.MultiLinestring([]string{"Transport", "Time(sec)"})
				</th>
				if shared.ShowDisco {
					<th style="width:50px;">
						@frmt.MultiLinestring([]string{"Frigate", "Time(sec)"})
					</th>
					<th style="width:50px;">
						@frmt.MultiLinestring([]string{"Freighter", "Time(sec)"})
					</th>
				}
				<th style="width:50px;">Profit/v</th>
				<th style="width:5px;">Vol.</th>
				if shared.ShowDisco {
					<th style="width:5px;">@frmt.MultiLinestring([]string{"Ship", "cl."})</th>
				}
				<th style="width:100px;">System</th>
				<th style="width:25px;">
					@frmt.MultiLinestring([]string{"Nav", "Map"})
				</th>
				<th style="width:100px;">Dest. Faction</th>
				<th style="width:100px;">Dest. Name</th>
				<th style="width:100px;">Dest. Region</th>
				<th style="width:50px;">
					@frmt.MultiLinestring([]string{"Price", "to buy", "from base"})
				</th>
				<th style="width:50px;">
					@frmt.MultiLinestring([]string{"Price", "to sell", "to base"})
				</th>
				<th style="width:50px;">Commodity Nick</th>
				<th style="width:50px;">Dest. Nickname</th>
				<th style="width:50px;">Dest.X</th>
				<th style="width:50px;">Dest.Y</th>
				<th style="width:50px;">Dest.Z</th>
				<th style="max-width:100%;"></th>
			</tr>
		</thead>
		<tbody>
			{ children... }
		</tbody>
	</table>
}

templ TradeRouteHumanTime(route *configs_export.Route) {
	if route.GetTimeMs() < trades.INF/2 {
		{ fmt.Sprintf("%2.0f", math.Floor(route.GetTimeS()/60)) }m-{ fmt.Sprintf("%2.0f", route.GetTimeS() - 60*math.Floor(route.GetTimeS()/60)) }s
	} else {
		INF
	}
}


type Path struct{
	P RoundedFloat // Proffit per time. Has to be Short named
	S int // Total seconds
}

type RoundedFloat float64
func (r RoundedFloat) MarshalJSON() ([]byte, error) {
	return []byte(strconv.FormatFloat(float64(r), 'f', 5, 32)), nil
}


// func RoutesInfoJSON(trade_routes configs_export.BaseAllTradeRoutes, shared *types.SharedData, route_type trades.RouteShipType) string {
// 	return "" // turning on this feature because it is bugged

// 	var result []Path
// 	for _, trade_route := range trade_routes.TradeRoutes {
// 		switch route_type {
// 			case trades.RouteTransport:
// 				result = append(result, Path{
// 					P: RoundedFloat(trade_route.Transport.GetProffitPerTime()),
// 					S: int(trade_route.Transport.Route.GetTime()),
// 				})
// 			case trades.RouteFrigate:
// 				result = append(result, Path{
// 					P: RoundedFloat(trade_route.Frigate.GetProffitPerTime()),
// 					S: int(trade_route.Frigate.Route.GetTime()),
// 				})
// 			case trades.RouteFreighter:
// 				result = append(result, Path{
// 					P: RoundedFloat(trade_route.Freighter.GetProffitPerTime()),
// 					S: int(trade_route.Freighter.Route.GetTime()),
// 				})
// 			}
// 	}
// 	bytes, _ := json.Marshal(result)
// 	return string(bytes)
// }

templ BaseTrades(name string, base *configs_export.Base, tab_mode BaseMode, shared *types.SharedData, 	data *configs_export.Exporter) {
	@tab.BottomFilterBar()
	<div class="bottom_name">{ name }</div>
	@BaseTradesShared(shared) {
		for _, trade_route := range data.GetBaseTradePathsFiltered(base).TradeRoutes {
			<tr
				hx-get={ types.GetCtx(ctx).SiteRoot + RouteUrl(trade_route.Transport.Route) }
				hx-trigger="click"
				hx-target="#infocard_view"
				hx-swap="innerHTML"
				preload="mouseover"
				onclick="RowHighlighter(this)"
			>
				<td>
					@frmt.WriteLimit(200) {
						{ trade_route.Transport.Commodity.Name + frmt.FormattedShipClassOfCommodity(trade_route.Transport.Commodity.ShipClass) }
					}
				</td>
				<td class="route_transport" routetime={ fmt.Sprintf("%.2f",trade_route.Transport.Route.GetTimeS()) } >{ fmt.Sprintf("%.2f", trade_route.Transport.GetProffitPerTime() * 100) }</td>
				if shared.ShowDisco {
					<td class="route_frigate" routetime={ fmt.Sprintf("%.2f",trade_route.Transport.Route.GetTimeS()) } >{ fmt.Sprintf("%.2f", trade_route.Frigate.GetProffitPerTime() * 100) }</td>
					<td class="route_freighter" routetime={ fmt.Sprintf("%.2f",trade_route.Transport.Route.GetTimeS()) } >{ fmt.Sprintf("%.2f", trade_route.Freighter.GetProffitPerTime() * 100) }</td>
				}
				<td>
					<span class="tooltip">
						@TradeRouteHumanTime(trade_route.Transport.Route)
						<span class="tooltiptext">
							if trade_route.Transport.Route.GetTimeMs() < trades.INF/2 {
								{ fmt.Sprintf("%.0f", trade_route.Transport.Route.GetTimeS()) } secs
							} else {
								INF secs
							}
						</span>
					</span>
				</td>
				if shared.ShowDisco {
					<td>
						<span class="tooltip">
							@TradeRouteHumanTime(trade_route.Frigate.Route)
							<span class="tooltiptext">
								if trade_route.Frigate.Route.GetTimeMs() < trades.INF/2 {
									{ fmt.Sprintf("%.0f", trade_route.Frigate.Route.GetTimeS()) } secs
								} else {
									INF secs
								}
							</span>
						</span>
					</td>
					<td>
						<span class="tooltip">
							@TradeRouteHumanTime(trade_route.Freighter.Route)
							<span class="tooltiptext">
								if trade_route.Freighter.Route.GetTimeMs() < trades.INF/2 {
									{ fmt.Sprintf("%.0f", trade_route.Freighter.Route.GetTimeS()) } secs
								} else {
									INF secs
								}
							</span>
						</span>
					</td>
				}
				<td>{ fmt.Sprintf("%.2f", configs_export.GetPricePerVoume(trade_route.Transport.SellingGood.GetPriceBaseBuysFor() - trade_route.Transport.BuyingGood.PriceBaseSellsFor, trade_route.Transport.BuyingGood.Volume)) }</td>
				<td>{ fmt.Sprintf("%.2f", trade_route.Transport.Commodity.Volume) }</td>
				if shared.ShowDisco {
					<td>{ frmt.FormattedShipClassOfCommodity2(trade_route.Transport.Commodity.ShipClass) }</td>
				}
				<td>
					@frmt.WriteSystemName(trade_route.Transport.SellingGood.SystemName)
				</td>
				<td>{ trade_route.Transport.SellingGood.SectorCoord }</td>
				<td>
					@frmt.WriteFactioName(trade_route.Transport.SellingGood.FactionName)
				</td>
				<td>
					@frmt.WriteBaseName(trade_route.Transport.SellingGood.BaseName)
				</td>
				<td>
					@frmt.WriteRegionName(trade_route.Transport.SellingGood.Region)
				</td>
				<td>{ strconv.Itoa(trade_route.Transport.BuyingGood.PriceBaseSellsFor) }</td>
				<td>{ strconv.Itoa(trade_route.Transport.SellingGood.GetPriceBaseBuysFor()) }</td>
				<td>{ trade_route.Transport.Commodity.Nickname }</td>
				<td>
					@frmt.WriteLimit(100) {
						{ trade_route.Transport.SellingGood.BaseNickname.ToStr() }
					}
				</td>
				<td>{ fmt.Sprintf("%.0f", trade_route.Transport.SellingGood.BasePos.X) }</td>
				<td>{ fmt.Sprintf("%.0f", trade_route.Transport.SellingGood.BasePos.Y) }</td>
				<td>{ fmt.Sprintf("%.0f", trade_route.Transport.SellingGood.BasePos.Z) }</td>
				<td></td>
			</tr>
		}
	}
	if tab_mode == BaseTabTrades || tab_mode == BaseTabOres {
		<script type="text/javascript">
			// To prevent the variables from leaking into the global scope,
		// this script is wrapped in an IIFE (Immediately Invoked Function Expression).
			(() => {
				FilteringForDistAfterRender()
				const input_field = document.querySelector('#input_route_min_dist')
				input_field.addEventListener('keyup', FilteringForDistAfterRender)
			})()
		</script>
	}
}

templ TradeRouteInfo3(BuyingGood *configs_export.MarketGood, SellingGood *configs_export.MarketGood, e *configs_export.Exporter, shared *types.SharedData) {
	@TradeRouteInfo(
		configs_export.NewRoute(e.Transport, BuyingGood.BaseNickname.ToStr(), SellingGood.BaseNickname.ToStr()),
		configs_export.NewRoute(e.Frigate, BuyingGood.BaseNickname.ToStr(), SellingGood.BaseNickname.ToStr()),
		configs_export.NewRoute(e.Freighter, BuyingGood.BaseNickname.ToStr(), SellingGood.BaseNickname.ToStr()),
		shared,
	)
}

templ TradeRouteInfo2(FromBase *configs_export.Base, ToBase *configs_export.Base, e *configs_export.Exporter, shared *types.SharedData) {
	@TradeRouteInfo(
		configs_export.NewRoute(e.Transport, FromBase.Nickname.ToStr(), ToBase.Nickname.ToStr()),
		configs_export.NewRoute(e.Frigate, FromBase.Nickname.ToStr(), ToBase.Nickname.ToStr()),
		configs_export.NewRoute(e.Freighter, FromBase.Nickname.ToStr(), ToBase.Nickname.ToStr()),
		shared,
	)
}

templ TradeRouteInfo(TransportRoute *configs_export.Route, FrigateRoute *configs_export.Route, FreighterRoute *configs_export.Route, shared *types.SharedData) {
	@tab.InfocardShared() {
		<style>
			.infocard p {
				font-size: 1.0em;
			}
		</style>
		<p>{ ">" } AvgTradeLaneSpeed: { strconv.Itoa(shared.AverageTradeLaneSpeed) }</p>
		<p>{ ">" } JumpHoleDelaySec: { strconv.Itoa(trades.JumpHoleDelaySec) }</p>
		<p>{ ">" } TradeLaneDockingDelaySec: { strconv.Itoa(trades.TradeLaneDockingDelaySec) }</p>
		<p>{ ">" } BaseDockingDelay: { strconv.Itoa(trades.BaseDockingDelay) }</p>
		<br/>
		@RouteInfo("Transport", TransportRoute, shared)
		if shared.ShowDisco {
			<br/>
			@RouteInfo("Frigate", FrigateRoute, shared)
			<br/>
			@RouteInfo("Freighter", FreighterRoute, shared)
		}
	}
}

templ RouteInfo(name string, route *configs_export.Route, shared *types.SharedData) {
	<p>{ name } Route:</p>
	<p>{ ">" } Avg Cruise Speed: { strconv.Itoa(route.GetCruiseSpeed()) }</p>
	<p>{ ">" } Visit Freighter Only JHs: { strconv.FormatBool(route.GetCanVisitFreighterOnlyJH()) }</p>
	for _, path := range route.GetPaths() {
		if path.NextName != "" {
			if path.Dist != 0 {
				<p>
				@TooltipDestination(path.Pos, shared)
				{ route.GetNameByIdsName(path.NextIdsName) } ({ path.NextName }) [ { path.SectorCoord }] - { strconv.Itoa(path.TimeMinutes) }m { strconv.Itoa(path.TimeSeconds) }s
				</p>
			}
		}
	}
}

templ TooltipDestination(Pos cfg.Vector, shared *types.SharedData) {
	<span class="tooltip">
		@frmt.MagnifyingGlass()
		<span class="tooltiptext" style="left: 0px; top: 30px;">
			if shared.ShowDisco {
				{ fmt.Sprintf("/wp %.0f %.0f %.0f",Pos.X,Pos.Y,Pos.Z) } <br/>
				command to create waypoint
			} else {
				coordinates:
				{ fmt.Sprintf("X %.0f,Y %.0f,Z %.0f",Pos.X,Pos.Y,Pos.Z) }
			}
		</span>
	</span>
}

